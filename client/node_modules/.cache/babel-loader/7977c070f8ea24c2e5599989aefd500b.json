{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _tslib = require('../../_tslib-bcbe0269.js');\n\nrequire('../colors.js');\n\nvar findPaletteByColor = require('./findPaletteByColor.js');\n\nvar monochromePaletteKeys = [\"darker\", \"dark\", \"base\", \"light\", \"lighter\"];\n\nvar colorPaletteKeys = _tslib.__spreadArrays([\"darkest\"], monochromePaletteKeys, [\"lightest\"]);\n\nfunction isColorPalette(palette) {\n  return Object.prototype.hasOwnProperty.call(palette, \"darkest\");\n}\n/**\r\n * Given a color and a palette the color belongs to, find another color in that\r\n * palette given an offset. The offset should be a number representing how many\r\n * shades darker or lighter we want with the direction specificed by\r\n * `offsetDirection`. If we try to go beyond the bounds, we'll return the\r\n * closest item we can. In other words, if we pass `Infinity` and `darker`, then\r\n * we'll return the darkest color in the palette. If we pass `Infinity` and `lighter` we'll\r\n * return the lightest color in the palette.\r\n *\r\n * This function will throw if `color` is not one of the values in `palette`.\r\n *\r\n * @param offset A number representing how many shades away from the original\r\n * `color` to return. If the offset goes beyond the bounds of the palette, the most extreme color\r\n * in that direction will be chosen.\r\n * @param offsetDirection Which direction we wish to be offset, `\"lighter\"` or `\"darker\"`.\r\n * @param color A color in one of our palettes\r\n */\n\n\nfunction getOffsetInPalette(offset, offsetDirection, color) {\n  /**\r\n   * Palette this color belongs to\r\n   */\n  var palette = findPaletteByColor.findPaletteByColor(color);\n  /**\r\n   * A numerical value of the offset with the `offsetDirection` taken into\r\n   * account. This will be positive for lighter values and negative for darker\r\n   * values.\r\n   */\n\n  var effectiveOffset = offsetDirection === \"lighter\" ? offset : -offset;\n\n  if (isColorPalette(palette)) {\n    var index_1 = Object.keys(palette).findIndex(function (paletteKey) {\n      return palette[paletteKey] === color;\n    }); // Use `max` to prevent a negative number. We explicitly do not throw an\n    // error here.\n\n    return palette[colorPaletteKeys[Math.min(Object.keys(palette).length - 1, Math.max(0, index_1 + effectiveOffset))]];\n  }\n\n  var index = Object.keys(palette).findIndex(function (paletteKey) {\n    return palette[paletteKey] === color;\n  }); // Use `max` to prevent a negative number. We explicitly do not throw an\n  // error here.\n\n  return palette[monochromePaletteKeys[Math.min(Object.keys(palette).length - 1, Math.max(0, index + effectiveOffset))]];\n}\n\nexports.getOffsetInPalette = getOffsetInPalette;","map":{"version":3,"sources":["../../src/colors/utils/getOffsetInPalette.ts"],"names":["monochromePaletteKeys","colorPaletteKeys","__spreadArrays","Object","getOffsetInPalette","offset","offsetDirection","color","palette","findPaletteByColor","effectiveOffset","isColorPalette","index_1","Math","index"],"mappings":";;;;;;;;;;;;AAGA,IAAMA,qBAAqB,GAA2C,CAAA,QAAA,EAAA,MAAA,EAAA,MAAA,EAAA,OAAA,EAAtE,SAAsE,CAAtE;;AAQA,IAAMC,gBAAgB,GAAsCC,MAAAA,CAAAA,cAAAA,CAAAA,CAC1D,SAD0DA,CAAAA,EAEvDF,qBAFuDE,EAEvDF,CAFL,UAEKA,CAFuDE,CAA5D;;AAMA,SAAA,cAAA,CAAA,OAAA,EAAA;SAGSC,MAAM,CAANA,SAAAA,CAAAA,cAAAA,CAAAA,IAAAA,CAAAA,OAAAA,EAAP,SAAOA,C;;;;;;;;;;;;;;;;;;;;;AAoBT,SAAgBC,kBAAhB,CACEC,MADF,EAEEC,eAFF,EAGEC,KAHF,EAGEA;;;;MAKMC,OAAO,GAAGC,kBAAAA,CAAAA,kBAAAA,CAAhB,KAAgBA,C;;;;;;;MAOVC,eAAe,GAAGJ,eAAe,KAAfA,SAAAA,GAAAA,MAAAA,GAAyC,CAAjE,M;;MAEIK,cAAc,CAAlB,OAAkB,C,EAAW;QACrBC,OAAK,GAAG,MAAM,CAAN,IAAA,CAAA,OAAA,EAAA,SAAA,CACZ,UAAA,UAAA,EAAA;aAAgBJ,OAAO,CAAPA,UAAO,CAAPA,KAAAA,K;AAFS,KACb,C,CADa,CAAA;;;WAOpBA,OAAO,CACZP,gBAAgB,CACdY,IAAI,CAAJA,GAAAA,CACEV,MAAM,CAANA,IAAAA,CAAAA,OAAAA,EAAAA,MAAAA,GADFU,CAAAA,EAEEA,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAYD,OAAK,GAJvB,eAIMC,CAFFA,CADc,CADJ,C;;;MAUVC,KAAK,GAAG,MAAM,CAAN,IAAA,CAAA,OAAA,EAAA,SAAA,CACZ,UAAA,UAAA,EAAA;WAAgBN,OAAO,CAAPA,UAAO,CAAPA,KAAAA,K;AADlB,GAAc,C,CA/BdD,CA+BA;;;SAMOC,OAAO,CACZR,qBAAqB,CACnBa,IAAI,CAAJA,GAAAA,CACEV,MAAM,CAANA,IAAAA,CAAAA,OAAAA,EAAAA,MAAAA,GADFU,CAAAA,EAEEA,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAYC,KAAK,GAJvB,eAIMD,CAFFA,CADmB,CADT,C","sourcesContent":["import { MonochromePalette, ColorPalette, ShadedColor } from \"../index\";\nimport { findPaletteByColor } from \"./findPaletteByColor\";\n\nconst monochromePaletteKeys: ReadonlyArray<keyof MonochromePalette> = [\n  \"darker\",\n  \"dark\",\n  \"base\",\n  \"light\",\n  \"lighter\",\n] as const;\n\nconst colorPaletteKeys: ReadonlyArray<keyof ColorPalette> = [\n  \"darkest\",\n  ...monochromePaletteKeys,\n  \"lightest\",\n] as const;\n\nfunction isColorPalette(\n  palette: MonochromePalette | ColorPalette,\n): palette is ColorPalette {\n  return Object.prototype.hasOwnProperty.call(palette, \"darkest\");\n}\n\n/**\n * Given a color and a palette the color belongs to, find another color in that\n * palette given an offset. The offset should be a number representing how many\n * shades darker or lighter we want with the direction specificed by\n * `offsetDirection`. If we try to go beyond the bounds, we'll return the\n * closest item we can. In other words, if we pass `Infinity` and `darker`, then\n * we'll return the darkest color in the palette. If we pass `Infinity` and `lighter` we'll\n * return the lightest color in the palette.\n *\n * This function will throw if `color` is not one of the values in `palette`.\n *\n * @param offset A number representing how many shades away from the original\n * `color` to return. If the offset goes beyond the bounds of the palette, the most extreme color\n * in that direction will be chosen.\n * @param offsetDirection Which direction we wish to be offset, `\"lighter\"` or `\"darker\"`.\n * @param color A color in one of our palettes\n */\nexport function getOffsetInPalette(\n  offset: number,\n  offsetDirection: \"lighter\" | \"darker\",\n  color: ShadedColor,\n): ShadedColor {\n  /**\n   * Palette this color belongs to\n   */\n  const palette = findPaletteByColor(color);\n\n  /**\n   * A numerical value of the offset with the `offsetDirection` taken into\n   * account. This will be positive for lighter values and negative for darker\n   * values.\n   */\n  const effectiveOffset = offsetDirection === \"lighter\" ? offset : -offset;\n\n  if (isColorPalette(palette)) {\n    const index = Object.keys(palette).findIndex(\n      (paletteKey) => palette[paletteKey as keyof ColorPalette] === color,\n    );\n\n    // Use `max` to prevent a negative number. We explicitly do not throw an\n    // error here.\n    return palette[\n      colorPaletteKeys[\n        Math.min(\n          Object.keys(palette).length - 1,\n          Math.max(0, index + effectiveOffset),\n        )\n      ]\n    ] as ShadedColor;\n  }\n\n  const index = Object.keys(palette).findIndex(\n    (paletteKey) => palette[paletteKey as keyof MonochromePalette] === color,\n  );\n\n  // Use `max` to prevent a negative number. We explicitly do not throw an\n  // error here.\n  return palette[\n    monochromePaletteKeys[\n      Math.min(\n        Object.keys(palette).length - 1,\n        Math.max(0, index + effectiveOffset),\n      )\n    ]\n  ] as ShadedColor;\n}\n"]},"metadata":{},"sourceType":"script"}